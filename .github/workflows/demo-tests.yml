name: Demo tests
run-name: Demo tests ${{ inputs.parent_run_id && format('parent_run_id:{0}', inputs.parent_run_id) || '' }}

on:
  workflow_dispatch:
    inputs:
      docker-image:
        description: "Docker image used in tests"
        required: false
        type: string
        default: "harbor.ci.tenstorrent.net/ghcr.io/tenstorrent/tt-forge/tt-forge-slim:latest"
      parent_run_id:
        description: "Parent run id is used to track child workflows in automated dispatch workflow calls"
        required: false
        type: string
        default: ""
      project-filter:
        description: "Project filter"
        required: false
        type: choice
        options:
          - tt-forge-fe
          - tt-torch
          - tt-xla
          - All
        default: All
      test-filter:
        description: "Only run tests that contains"
        required: false
        type: string
        default: ""
  workflow_call:
    inputs:
      docker-image:
        description: "Docker image used in tests"
        required: true
        type: string
      project-filter:
        description: "Project filter"
        type: string
        required: false
        default: "All"

jobs:
  set-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix-json.outputs.matrix }}
      matrix_skip: ${{ steps.set-matrix-json.outputs.matrix_skip }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    - name: Filter Matrix
      id: set-matrix-json
      shell: bash
      run: |
        matrix_skip="false"
        # Start with a basic filter that selects all items
        filter='.[] | select(true'

        # Add frontend filter if specified
        if [ "${{ inputs.project-filter }}" != "All" ]; then
          project="${{ inputs.project-filter }}"
          filter="$filter and .frontend == \"$project\""
        fi

        # Add test name filter if specified
        if [ -n "${{ inputs.test-filter }}" ]; then
          filter="$filter and .name == \"${{ inputs.test-filter }}\""
        fi

        # Close the select statement
        filter="$filter)"

        echo "filter=$filter"

        # Apply the filter to the matrix JSON file
        matrix=$(jq -c "[${filter}]" .github/workflows/models-matrix.json)

        # Check if any tests matched our filter criteria
        if [ "$matrix" == "[]" ]; then
          echo "Error: No matching tests found in the matrix"
          matrix_skip="true"
        fi

        echo "matrix=$matrix"
        echo "matrix_skip=$matrix_skip"
        echo "matrix=$matrix" >> $GITHUB_OUTPUT
        echo "matrix_skip=$matrix_skip" >> $GITHUB_OUTPUT

  demo-test:
    if: ${{ needs.set-matrix.outputs.matrix_skip == 'false' }}
    needs: set-matrix
    name: Demo ${{ matrix.frontend }} ${{ matrix.name }} on ${{ matrix.runs-on }}
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.set-matrix.outputs.matrix) }}

    runs-on: ${{ matrix.runs-on && format('tt-ubuntu-2204-{0}-stable', matrix.runs-on) }}
    container:
      image: ${{ inputs.docker-image }}
      options: --device /dev/tenstorrent
      volumes:
        - /dev/hugepages:/dev/hugepages
        - /dev/hugepages-1G:/dev/hugepages-1G
        - /etc/udev/rules.d:/etc/udev/rules.d
        - /lib/modules:/lib/modules
        - /opt/tt_metal_infra/provisioning/provisioning_env:/opt/tt_metal_infra/provisioning/provisioning_env

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for all branches and tags
          submodules: 'recursive'

      - name: Fix HOME Directory
        shell: bash
        run: |
          # Issue [HOME is overridden for containers](https://github.com/actions/runner/issues/863)
          h=$(getent passwd $(id -un) | cut -d: -f6)
          if [ "$h" = "$HOME" ]; then
            echo "HOME fine: $HOME"
            exit 0
          fi
          echo "HOME=$HOME was broken. Setting it to $h"
          ls -ld $HOME
          ls -ld $h
          echo "USER: $USER"
          echo "id: $(id)"
          echo "HOME=$h" >> $GITHUB_ENV

      - name: Install system and python dependencies
        shell: bash
        run: |
          if [ -n "${{ matrix.libreq }}" ]; then
            apt-get install -y -qq --no-install-recommends ${{ matrix.libreq }}
          fi

          if [ -f /home/forge/venv-${{ matrix.frontend }}/bin/activate ]; then
            echo "Using /home/forge/venv-${{ matrix.frontend }}"
            source /home/forge/venv-${{ matrix.frontend }}/bin/activate
          fi

          if [ -n "${{ matrix.pyreq }}" ]; then
            pip install ${{ matrix.pyreq }}
          fi

          if [ "${{ matrix.pyreq_file }}" == "true" ]; then
            REQUIREMENTS_PATH=$(dirname demos/${{ matrix.frontend }}/${{ matrix.path }})
            pip install -r $REQUIREMENTS_PATH/requirements.txt
          fi

      - name: Instrumentation Python and Environment Details
        shell: bash
        continue-on-error: true
        run: |
          echo "Python Location: $(which python)" || true
          echo "Python Version: $(python --version)" || true
          echo "Python Site-Packages: $(python -c 'import site; print(site.getsitepackages()[0])')" || true
          echo "Python sys.prefix: $(python -c 'import sys; print(sys.prefix)')" || true
          echo "Listing contents around Python binary:" || true
          ls -l $(dirname $(which python)) || true
          echo "Listing contents of Python site-packages:" || true
          ls -l $(python -c 'import site; print(site.getsitepackages()[0])') || true
          echo "Listing contents of Python sys.prefix:" || true
          ls -l $(python -c 'import sys; print(sys.prefix)') || true
          echo "Installed Python Packages:" || true
          pip freeze || true
          echo "Details of tt_torch package:" || true
          pip show tt_torch || true
          TT_TORCH_PATH=$(pip show tt_torch | grep Location | cut -d' ' -f2)/tt_torch || true
          echo "Listing contents of tt_torch package directory:" || true
          ls -l $(dirname $TT_TORCH_PATH) || true

      - name: Apply Correct Patch to tt_torch __init__.py
        shell: bash
        run: |
          PATCH_FILE="/home/forge/.local/lib/python3.11/site-packages/tt_torch/__init__.py"
          if [ -f "$PATCH_FILE" ]; then
            echo "# SPDX-FileCopyrightText: (c) 2025 Tenstorrent AI ULC" > "$PATCH_FILE"
            echo "#" >> "$PATCH_FILE"
            echo "# SPDX-License-Identifier: Apache-2.0" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "# Process start method must be \"forkserver\" for op-by-op compilation for the following reasons:" >> "$PATCH_FILE"
            echo "#   - The backend will hang if attempting to retrieve the device descriptor from a forked process if there are multiple chips" >> "$PATCH_FILE"
            echo "#   - torch tensors cannot be made contiguous in a forked process" >> "$PATCH_FILE"
            echo "import multiprocessing as mp" >> "$PATCH_FILE"
            echo "import torch" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "if mp.get_start_method() != \"forkserver\":" >> "$PATCH_FILE"
            echo "    mp.set_start_method(\"forkserver\", force=True)" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "import os" >> "$PATCH_FILE"
            echo "import sys" >> "$PATCH_FILE"
            echo "import site" >> "$PATCH_FILE"
            echo "import importlib.util" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "# find the tt-metal directory, it can either be in the venv if installed from a wheel or in the third_party source tree" >> "$PATCH_FILE"
            echo "package_name = \"tt-metal\"" >> "$PATCH_FILE"
            echo "spec = importlib.util.find_spec(package_name)" >> "$PATCH_FILE"
            echo "if spec is not None:" >> "$PATCH_FILE"
            echo "    tt_metal_home = os.path.abspath(spec.submodule_search_locations[0])" >> "$PATCH_FILE"
            echo "    os.environ[\"TT_METAL_HOME\"] = tt_metal_home" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "# Import these modules so backends are registered (\"tt\", and \"tt-experimental\")" >> "$PATCH_FILE"
            echo "import tt_torch.dynamo.backend" >> "$PATCH_FILE"
            echo "import tt_torch.dynamo.experimental.xla_backend" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "from torch_xla.experimental import plugins" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "class TTPjrtPlugin(plugins.DevicePlugin):" >> "$PATCH_FILE"
            echo "    def library_path(self):" >> "$PATCH_FILE"
            echo "        # This is where the pjrt plugin will be located if you've built and installed from source" >> "$PATCH_FILE"
            echo "        direct_build_install_path = os.path.join(" >> "$PATCH_FILE"
            echo "            os.path.dirname(__file__), \"../install/pjrt_plugin_tt.so\"" >> "$PATCH_FILE"
            echo "        )" >> "$PATCH_FILE"
            echo "        if os.path.exists(direct_build_install_path):" >> "$PATCH_FILE"
            echo "            return direct_build_install_path" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "        # This is where the pjrt plugin will be located if you've installed the tt-torch wheel into a virtual environment" >> "$PATCH_FILE"
            echo "        env_path = os.path.join(os.path.dirname(__file__), \"../../../pjrt_plugin_tt.so\")" >> "$PATCH_FILE"
            echo "        if os.path.exists(env_path):" >> "$PATCH_FILE"
            echo "            return env_path" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "        # This is where the pjrt plugin will be located if you've only built and installed the wheel - but you're running your code with" >> "$PATCH_FILE"
            echo "        # the root of the source tree in which an env was already activated (CI does this)" >> "$PATCH_FILE"
            echo "        source_path = os.path.join(" >> "$PATCH_FILE"
            echo "            os.path.dirname(__file__), \"../env/venv/lib/pjrt_plugin_tt.so\"" >> "$PATCH_FILE"
            echo "        )" >> "$PATCH_FILE"
            echo "        if os.path.exists(source_path):" >> "$PATCH_FILE"
            echo "            return source_path" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "        # This is where the pjrt plugin will be located if you've installed the tt-torch wheel in a clean virtual environment" >> "$PATCH_FILE"
            echo "        # Use sys.prefix to get the venv root instead of relative paths" >> "$PATCH_FILE"
            echo "        venv_install_path = os.path.join(sys.prefix, \"pjrt_plugin_tt.so\")" >> "$PATCH_FILE"
            echo "        if os.path.exists(venv_install_path):" >> "$PATCH_FILE"
            echo "            return venv_install_path" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "        # For a user site-packages installation / global pip package installation, check the user site-packages directory" >> "$PATCH_FILE"
            echo "        user_site_packages_path = site.getusersitepackages()" >> "$PATCH_FILE"
            echo "        user_site_package_install_pjrt_path = os.path.normpath(" >> "$PATCH_FILE"
            echo "            os.path.join(user_site_packages_path, \"../../../pjrt_plugin_tt.so\")" >> "$PATCH_FILE"
            echo "        )" >> "$PATCH_FILE"
            echo "        if os.path.exists(user_site_package_install_pjrt_path):" >> "$PATCH_FILE"
            echo "            return user_site_package_install_pjrt_path" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "        assert False, \"Could not find pjrt_plugin_tt.so\"" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "" >> "$PATCH_FILE"
            echo "plugins.register_plugin(\"TT\", TTPjrtPlugin())" >> "$PATCH_FILE"
            echo "os.environ[\"XLA_STABLEHLO_COMPILE\"] = \"1\"" >> "$PATCH_FILE"
            echo "os.environ[\"PJRT_DEVICE\"] = \"TT\"" >> "$PATCH_FILE"
          else
            echo "File $PATCH_FILE does not exist. Skipping patch.";
          fi

      - name: Run ${{ matrix.frontend }} demo ${{ matrix.name }}
        shell: bash
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
          HF_HOME: /home/forge/huggingface
          # TODO: Revisit the addition of these env vars https://github.com/tenstorrent/tt-metal/issues/20161
          TRACY_NO_INVARIANT_CHECK: 1
          IRD_LF_CACHE: ${{ vars.IRD_LF_CACHE }}
        run: |
          if [ -f /home/forge/venv-${{ matrix.frontend }}/bin/activate ]; then
            echo "Using /home/forge/venv-${{ matrix.frontend }}"
            source /home/forge/venv-${{ matrix.frontend }}/bin/activate
            pip list | grep -E 'tt_|tt-|pjrt-' # Print installed version
          fi

          third_party_models="$(realpath third_party)"
          demo_folder=$(dirname demos/${{ matrix.frontend }}/${{ matrix.path }})
          cd $demo_folder
          ln -s $third_party_models third_party
          demo_file=$(basename "${{ matrix.path }}")
          python $demo_file


  fail-notify:
    if: always()
    needs:
      - demo-test
    runs-on: ubuntu-latest
    outputs:
      is-main: ${{ steps.branch-check.outputs.IS_MAIN }}
      failed: ${{ steps.check.outputs.failure }}
      is-draft: ${{ steps.draft-check.outputs.IS_DRAFT }}
    steps:
      - name: Check if branch is main
        id: branch-check
        run: echo "IS_MAIN=$(if [ '${{ github.ref }}' == 'refs/heads/main' ]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
      - name: Check draft
        id: draft-check
        run: |
          parent_run_id="${{ inputs.parent_run_id }}"
          set +e
          draft_check="$(echo "$parent_run_id" | grep 'draft')"
          set -e
          echo "draft_check=$draft_check"
          IS_DRAFT="$(if [ -n "$draft_check" ]; then echo true; else echo false; fi)"
          echo "IS_DRAFT=$IS_DRAFT"
          echo "IS_DRAFT=$IS_DRAFT" >> $GITHUB_OUTPUT
      - name: Check if the needed jobs succeeded or failed
        id: check
        uses: re-actors/alls-green@release/v1
        with:
          jobs: ${{ toJSON(needs) }}
          allowed-skips: demo-test

  fail-send-msg:
    if: always()
    needs:
      - fail-notify
    runs-on: ubuntu-latest
    steps:
      - name: Send Fail Notification
        if: ${{ needs.fail-notify.outputs.failed == 'true' && needs.fail-notify.outputs.is-main == 'true' && needs.fail-notify.outputs.is-draft == 'false' }}
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "Demo tests ${{ inputs.project-filter }} failed: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/attempts/${{ github.run_attempt }}",
              "channel": "C088QN7E0R3"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ inputs.slack-token || secrets.SLACK_NIGHTLY_FAIL }}
